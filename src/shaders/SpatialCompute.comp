#version 460
// @TODO: REMEMBER THE NORMALS FROM THE GBUFFER ARE 0-1 AND NEED TO BE CONVERTED BACK TO
// -1-1 RANGE BY DOING * 2.0 - 1.0

#extension GL_EXT_ray_query : enable
#extension GL_EXT_ray_tracing : enable

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

const int NUM_LIGHTS = 100;

#define PI 3.14159265359

struct Light
{
	int Type;
	vec4 LightPosition;
	vec4 LightColour;
	mat4 LightSpaceMatrix;
};

layout(set = 0, binding = 0) uniform SpatialPassUniforms
{
    int frameIndex;
    vec2 viewportSize;
    int M;
    int radius;
} spatial_ubo;


layout(set = 0, binding = 1) uniform LightBuffer {
	Light lights[NUM_LIGHTS];
} lightData;

layout(set = 0, binding = 2) uniform sampler2D initial_candidates_texture;
layout(set = 0, binding = 3) uniform sampler2D hit_world_position_texture;
layout(set = 0, binding = 4) uniform sampler2D hit_normals_texture;
layout(set = 0, binding = 5) uniform sampler2D hit_albedo;
layout(set = 0, binding = 6) uniform sampler2D temporal_pass_reservoirs;
layout(set = 0, binding = 7, rgba32f) uniform image2D reservoir_output_image;
layout(set = 0, binding = 8, rgba32f) uniform image2D shading_result_image;

layout(set = 0, binding = 9) uniform accelerationStructureEXT topLevelAS;

layout(set = 0, binding = 10) uniform sampler2D g_buffer_world_position;
layout(set = 0, binding = 11) uniform sampler2D g_buffer_normals;
layout(set = 0, binding = 12) uniform sampler2D g_albedo;

struct Reservoir
{
    int index;
    float W_y;
    float totalWeights;
    int M;
};
// Reference: https://github.com/NVIDIAGameWorks/RTXGI-DDGI/blob/main/samples/test-harness/shaders/include/Random.hlsl#L42
uint WangHash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

uint Xorshift(uint seed)
{
    // Xorshift algorithm from George Marsaglia's paper
    seed ^= (seed << 13);
    seed ^= (seed >> 17);
    seed ^= (seed << 5);
    return seed;
}

float GetRandomNumber(inout uint seed)
{
    seed = WangHash(seed);
    return float(Xorshift(seed)) * (1.f / 4294967296.f);
}

vec2 GetRandomHashValue01(inout uint seed)
{
    float u = GetRandomNumber(seed);
    float v = GetRandomNumber(seed);
    return vec2(u, v);
}


vec2 GetRandomHashValue(inout uint seed)
{
    float u = GetRandomNumber(seed) * 2.0 - 1.0;
    float v = GetRandomNumber(seed) * 2.0 - 1.0; // Seed is modified in-place
    return vec2(u, v);
}

float RadicalInverse_VdC(uint bits)
{
    bits = (bits << 16u) | (bits >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    return float(bits) * 2.3283064365386963e-10; // / 0x100000000
}

vec2 Hammersley(uint i, uint N)
{
    return vec2(float(i)/float(N), RadicalInverse_VdC(i));
}

vec2 DiskPoint(float sampleRadius, float x, float y)
{
	float r = sampleRadius * sqrt(x);
	float theta = y * (2.0 * PI);
	return vec2(r * cos(theta), r * sin(theta));
}

float inShadow(vec3 position, vec3 normal, float distToLight, vec3 lightDir)
{
    rayQueryEXT rq;
    rayQueryInitializeEXT(rq, topLevelAS,
                          gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT,
                          0xFF,
                          position + normal * 0.001, // offset to avoid self-intersection
                          0.0,
                          lightDir,
                          distToLight);

    while (rayQueryProceedEXT(rq)) {
        // Just keep iterating until first hit or end
    }
    bool occluded = rayQueryGetIntersectionTypeEXT(rq, true) != gl_RayQueryCommittedIntersectionNoneEXT;

    return occluded ? 0.0 : 1.0;
}

void update(uint seed, inout Reservoir reservoir, in float xi_weight, int index, int in_reservoir_m)
{
    reservoir.totalWeights = reservoir.totalWeights + xi_weight;
    float r = GetRandomNumber(seed);
    reservoir.M += in_reservoir_m;
    if(r < (xi_weight / reservoir.totalWeights))
    {
        reservoir.index = index;
    }
}

Reservoir combine_reservoirs_spatial_reuse(vec4 current_pixel_reservoir_data, inout uint seed, vec3 n, vec3 pos, inout float m)
{
    const int NUM_SPATIAL_NEIGHBOURS = 5; // 5 spatial neighbouring including the current pixel
    Reservoir reservoir;
    reservoir.index = -1;
    reservoir.W_y = 0.0;
    reservoir.M = 0;
    reservoir.totalWeights = 0.0;

    Reservoir neighbouring_reservoirs[NUM_SPATIAL_NEIGHBOURS]; // We will find 4 neighbours and fill this array
    vec3 neighbouring_positions[NUM_SPATIAL_NEIGHBOURS];
    vec3 neighbouring_normals[NUM_SPATIAL_NEIGHBOURS];

    // Init all reservoirs
    for(int i = 0; i < NUM_SPATIAL_NEIGHBOURS; i++)
    {
        neighbouring_reservoirs[i].index = -1;
        neighbouring_reservoirs[i].W_y = 0.0f;
        neighbouring_reservoirs[i].M = 0;
        neighbouring_reservoirs[i].totalWeights = 0.0f;
        neighbouring_positions[i] = vec3(0.0);
        neighbouring_normals[i] = vec3(0.0);
    }

    // current pixel reservoir
    ivec2 current_pixel = ivec2(gl_GlobalInvocationID.xy);
    neighbouring_reservoirs[0].index = int(current_pixel_reservoir_data.x); // Current pixel index
    neighbouring_reservoirs[0].W_y = current_pixel_reservoir_data.y; // Current pixel weight
    neighbouring_reservoirs[0].M = int(current_pixel_reservoir_data.z); // Current pixel M
    neighbouring_positions[0] = pos;
    neighbouring_normals[0] = n;

    for(uint i = 1; i < NUM_SPATIAL_NEIGHBOURS; i++)
    {
        vec2 rand = Hammersley(i, NUM_SPATIAL_NEIGHBOURS - 1);
        vec2 random = GetRandomHashValue01(seed);
        vec2 offset = DiskPoint(float(spatial_ubo.radius), random.x, random.y); // radius of 30px, as suggested by the paper

        ivec2 sample_pixel = current_pixel + ivec2(offset);
        ivec2 viewportSizeInt = ivec2(spatial_ubo.viewportSize);
        sample_pixel = clamp(sample_pixel, ivec2(0), viewportSizeInt - ivec2(1));

        neighbouring_reservoirs[i].index = int(texelFetch(temporal_pass_reservoirs, sample_pixel, 0).x);
        neighbouring_reservoirs[i].W_y   = texelFetch(temporal_pass_reservoirs, sample_pixel, 0).y;
        neighbouring_reservoirs[i].M     = min(int(texelFetch(temporal_pass_reservoirs, sample_pixel, 0).z), spatial_ubo.M); // 20 * int(current_pixel_reservoir_data.z)
        neighbouring_positions[i]        = texelFetch(g_buffer_world_position, sample_pixel, 0).xyz;
        neighbouring_normals[i]          = texelFetch(g_buffer_normals, sample_pixel, 0).xyz * 2.0 - 1.0; // convert from 0-1 to -1-1 range
    }

    // Update the reservoir using the neighbouring reservoirs
    for(uint i = 0; i < NUM_SPATIAL_NEIGHBOURS; i++)
    {
        Light L = lightData.lights[neighbouring_reservoirs[i].index];

        float dist = length(L.LightPosition.xyz - pos);
        const vec3 LightDir = normalize(L.LightPosition.xyz - pos);
        const float LightIntensity = 1000.0f * (1.0 / (dist * dist));

        // Evaluate F(x) at the current pixel
        float F_x = max(dot(n, LightDir), 0.0) * LightIntensity; // Simplied F(x) only doing diffuse

        // Algorithm 4: Line: 4: p^q(r.y) * r.W * r.M
        float w_i = F_x > 0.0 ? F_x * neighbouring_reservoirs[i].W_y * neighbouring_reservoirs[i].M : 0.0;

        // Update the reservoir using current sample data
        update(seed, reservoir, w_i, neighbouring_reservoirs[i].index, neighbouring_reservoirs[i].M);
    }


    // The resampling process results in a final sample in the reservoir which can now be used.
    Light L = lightData.lights[reservoir.index];
    int z = 0;
    for(uint i = 0; i < NUM_SPATIAL_NEIGHBOURS; i++)
    {
        float light_dist = length(L.LightPosition.xyz - neighbouring_positions[i]);
        vec3 lighting_direction = normalize(L.LightPosition.xyz - neighbouring_positions[i]);
        float attenuation = 1.0 / (light_dist * light_dist);
        float light_intensity = 1000.0f * attenuation;

        float visibility = inShadow(neighbouring_positions[i], neighbouring_normals[i], light_dist, lighting_direction);
        float pixel_p_hat = max(dot(neighbouring_normals[i], lighting_direction), 0.0) * light_intensity * visibility;
        if(pixel_p_hat > 0.0)
        {
            // Add the neighbouring pixels reservoir M to Z
            z = z + neighbouring_reservoirs[i].M;
        }
    }

    m = (z > 0) ? 1.0 / float(z) : 0.0;


    return reservoir;
}

vec4 Spatial(vec3 n, vec3 pos, vec3 albedo)
{
    uvec2 dispatchSize = uvec2(spatial_ubo.viewportSize / 8);
    uint launchWidth = dispatchSize.x * gl_WorkGroupSize.x;
    uint seed = uint(gl_GlobalInvocationID.y * launchWidth) + gl_GlobalInvocationID.x;
    seed *= spatial_ubo.frameIndex;

    vec3 throughput = vec3(1.0);
    vec4 pixelReservoir = texelFetch(temporal_pass_reservoirs, ivec2(gl_GlobalInvocationID.xy), 0).rgba;

    if(isnan(pixelReservoir.y))
    {
        return vec4(0., 1., 0.0, 1.0);
    }

    float m = 0.0;
    Reservoir reservoir = combine_reservoirs_spatial_reuse(pixelReservoir, seed, n, pos, m);

    // The reservoir should now contain the new updated sample
    // Use the index from the reservoir to fetch the light data

    bool isValidReservoir = reservoir.index >= 0;

    if(!isValidReservoir) {
        return vec4(1, 0, 0, 1); // No valid reservoir found, return empty
    }
    Light L = lightData.lights[reservoir.index];

    // Compute lighting using this light source
    vec3 LightDir = normalize(L.LightPosition.xyz - pos);
    float dist = length(L.LightPosition.xyz - pos);
    float att = 1.0 / (dist * dist);
    float LightIntensity = 1000.0f * att;
    float Fx = max(dot(n, LightDir), 0.0) * LightIntensity;

    float Visibility = inShadow(pos, n, dist, LightDir);

    // Algorithm 4
    // reservoir.W_y = Fx > 0.0 ? (1.0 / Fx) * (1.0 / reservoir.M) * reservoir.totalWeights : 0.0;

    // Algorithm 6:
    Fx = Fx * Visibility; // Apply visibility to F(x)
    reservoir.W_y = Fx > 0.0 ? (1.0 / Fx) * (m * reservoir.totalWeights) : 0.0;

    imageStore(reservoir_output_image, ivec2(gl_GlobalInvocationID.xy), vec4(reservoir.index, reservoir.W_y, reservoir.M, 0.0));

    vec3 directLighting = albedo * Fx * L.LightColour.rgb;
    vec3 radiance = throughput * directLighting * reservoir.W_y * Visibility;

    return vec4(radiance, 1.0);

}

void main() {

    ivec2 coords = ivec2(gl_GlobalInvocationID.xy);

    vec3 throughput = vec3(1.0);

    // Get world and normal data
    vec4 world_position = texelFetch(g_buffer_world_position, coords, 0);
    vec4 world_normal   = texelFetch(g_buffer_normals, coords, 0) * 2.0 - 1.0;
    // vec4 reservoir_from_temporal = texelFetch(temporal_pass_reservoirs, coords, 0);

    vec3 albedo = texelFetch(g_albedo, coords, 0).rgb;

    vec4 radiance = Spatial(world_normal.xyz, world_position.xyz, albedo);

//    uint reservoir_index = int(reservoir_from_temporal.x);
//    float reservoir_W_y = reservoir_from_temporal.y;
//    int M = int(reservoir_from_temporal.z);
//
//    vec4 finalColour = vec4(0);
//    bool is_invalid = false;
//    Light L = lightData.lights[reservoir_index];
//
//    // Compute lighting using this light source
//    vec3 LightDir = normalize(L.LightPosition.xyz - world_position.xyz);
//    float dist = length(L.LightPosition.xyz - world_position.xyz);
//    float att = 1.0 / (dist * dist);
//    float intensity = 1000.0f * att;
//    float Fx = max(dot(world_normal.xyz, LightDir), 0.001) * intensity; // Simplied F(x) only doing diffuse
//
//    float target_function = 1.0 / Fx;
//
//    if(isinf(target_function) || isnan(target_function))
//    {
//        is_invalid = true;
//    }
//
//    float Visibility = inShadow(world_position.xyz, world_normal.xyz, dist, LightDir);
//    vec3 directLighting = albedo * Fx * L.LightColour.rgb;
//    vec3 radiance = throughput * directLighting * reservoir_W_y;

    // radiance = is_invalid ? vec3(1, 0, 0) : radiance;
    imageStore(shading_result_image, coords, vec4(radiance.rgb, 0.0));

}